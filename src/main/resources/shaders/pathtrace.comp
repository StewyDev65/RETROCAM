#version 430 core
layout(local_size_x = 16, local_size_y = 16) in;

// ── Accumulation buffer (read previous sum, write new sum) ────────────────────
layout(rgba32f, binding = 0) uniform image2D u_accumBuffer;
layout(rgba16f, binding = 1) writeonly uniform image2D u_gBuffer;
layout(rgba16f, binding = 2) writeonly uniform image2D u_gAlbedo;     // first-hit albedo for irradiance demodulation
layout(r32f,    binding = 3) uniform image2D u_varianceBuffer;         // accumulated sum(luma²) for per-pixel variance

// ── Camera uniforms ───────────────────────────────────────────────────────────
uniform vec3  u_camPos;
uniform vec3  u_camRight;
uniform vec3  u_camUp;
uniform vec3  u_camForward;
uniform float u_focalDist;       // IIR-filtered focal distance (from TemporalState)
uniform float u_lensRadius;
uniform float u_fovTanHalf;
uniform int   u_apertureBlades;
uniform ivec2 u_resolution;
uniform int   u_frameIndex;      // 0 = first sample, clears accumulation

// ── Phase 4 optical uniforms ──────────────────────────────────────────────────
uniform float u_saStrength;      // Spherical aberration strength (default 0.04)
uniform vec3  u_lcaDelta;        // LCA focal offsets for R, G, B (e.g. -0.002, 0.0, +0.003)

// ── Temporal uniforms ─────────────────────────────────────────────────────────
uniform float u_agcGain;
uniform float u_time;
uniform float u_tapeAge;

// ── NEE uniforms ──────────────────────────────────────────────────────────────
uniform int   u_lightCount;         // number of emissive triangles in LightBuffer
uniform float u_totalLightPower;    // sum of (luminance * area * PI) over all lights
uniform int   u_neeEnabled;         // 1 = use Next Event Estimation, 0 = pure path trace
uniform float u_neeFireflyClamp;    // max NEE contribution multiplier (default 20.0)

// ── GPU Scene Data ────────────────────────────────────────────────────────────

struct Triangle {
    vec3 v0; float pad0;
    vec3 v1; float pad1;
    vec3 v2; float pad2;
    vec3 n0; float pad3;
    vec3 n1; float pad4;
    vec3 n2; float pad5;
    vec2 uv0; vec2 uv1;
    vec2 uv2; int matIndex; float pad6;
};

struct BVHNode {
    vec3 aabbMin; float pad0;
    vec3 aabbMax; float pad1;
    int leftChild; int rightChild; int primStart; int primCount;
};

struct Material {
    vec3  albedo;          float metallic;
    vec3  emission;        float emissionStrength;
    float roughness;       float ior; float transmission; int albedoTex;
    float p0; float p1; float p2; float p3;
};

// Light struct layout matches SceneUploader (std430, 20 floats = 80 bytes):
//   vec3 v0 + area | vec3 v1 + pad | vec3 v2 + pad | vec3 emission + power | vec3 normal + cdfWeight
struct Light {
    vec3 v0;       float area;
    vec3 v1;       float pad1;
    vec3 v2;       float pad2;
    vec3 emission; float power;
    vec3 normal;   float cdfWeight;
};

layout(std430, binding = 0) readonly buffer TriBuffer   { Triangle triangles[]; };
layout(std430, binding = 1) readonly buffer BVHBuffer   { BVHNode  nodes[];     };
layout(std430, binding = 2) readonly buffer MatBuffer   { Material materials[]; };
layout(std430, binding = 3) readonly buffer LightBuffer { Light    lights[];    };

// ── PCG hash RNG ──────────────────────────────────────────────────────────────

uint pcg(inout uint state) {
    state = state * 747796405u + 2891336453u;
    uint w = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (w >> 22u) ^ w;
}

float rand(inout uint state) {
    return float(pcg(state)) / 4294967296.0;
}

vec2 rand2(inout uint state) { return vec2(rand(state), rand(state)); }

// Each channel gets an independent seed to ensure uncorrelated Monte Carlo samples.
// Multiplying frameIndex by 3 ensures no seed aliasing between channels across frames.
uint initSeed(ivec2 pixel, int frame) {
    uint s = uint(pixel.x + pixel.y * 7919 + frame * 6271);
    pcg(s); pcg(s);
    return s;
}

// ── Geometry helpers ──────────────────────────────────────────────────────────

bool intersectAABB(vec3 ro, vec3 invRd, vec3 bmin, vec3 bmax, out float tmin) {
    vec3 t0 = (bmin - ro) * invRd;
    vec3 t1 = (bmax - ro) * invRd;
    vec3 lo = min(t0, t1);
    vec3 hi = max(t0, t1);
    tmin = max(max(lo.x, lo.y), lo.z);
    float tmax = min(min(hi.x, hi.y), hi.z);
    return tmax >= max(tmin, 0.0);
}

bool intersectTriangle(vec3 ro, vec3 rd, int idx, out float t, out vec2 bary) {
    Triangle tri = triangles[idx];
    vec3 e1 = tri.v1 - tri.v0;
    vec3 e2 = tri.v2 - tri.v0;
    vec3 h  = cross(rd, e2);
    float a = dot(e1, h);
    if (abs(a) < 1e-8) return false;
    float  f = 1.0 / a;
    vec3   s = ro - tri.v0;
    float  u = f * dot(s, h);
    if (u < 0.0 || u > 1.0) return false;
    vec3   q = cross(s, e1);
    float  v = f * dot(rd, q);
    if (v < 0.0 || u + v > 1.0) return false;
    t = f * dot(e2, q);
    if (t < 1e-4) return false;
    bary = vec2(u, v);
    return true;
}

// ── BVH traversal (full — returns closest hit) ────────────────────────────────

struct HitRecord {
    bool  valid;
    float t;
    vec3  pos;
    vec3  normal;
    int   matIndex;
};

HitRecord traverseBVH(vec3 ro, vec3 rd) {
    HitRecord rec;
    rec.valid = false;
    rec.t = 1e30;

    vec3 invRd = 1.0 / rd;

    int stack[64];
    int top = 0;
    stack[top++] = 0;

    while (top > 0) {
        int     idx  = stack[--top];
        BVHNode node = nodes[idx];

        float aabbT;
        if (!intersectAABB(ro, invRd, node.aabbMin, node.aabbMax, aabbT))
            continue;
        if (aabbT > rec.t) continue;

        if (node.primCount > 0) {
            for (int i = node.primStart; i < node.primStart + node.primCount; i++) {
                float t; vec2 bary;
                if (intersectTriangle(ro, rd, i, t, bary) && t < rec.t) {
                    rec.t    = t;
                    rec.pos  = ro + rd * t;
                    Triangle tri = triangles[i];
                    float w = 1.0 - bary.x - bary.y;
                    rec.normal   = normalize(tri.n0 * w + tri.n1 * bary.x + tri.n2 * bary.y);
                    rec.matIndex = tri.matIndex;
                    rec.valid    = true;
                }
            }
        } else {
            if (top < 62) {
                // Order children by AABB hit distance — nearer child lands on
                // top of the stack so it is processed first, allowing rec.t to
                // tighten sooner and the aabbT > rec.t check to cull the farther
                // subtree earlier.  (Aila & Laine 2009)
                float tLeft, tRight;
                bool hitLeft  = intersectAABB(ro, invRd, nodes[node.leftChild].aabbMin,
                                              nodes[node.leftChild].aabbMax, tLeft);
                bool hitRight = intersectAABB(ro, invRd, nodes[node.rightChild].aabbMin,
                                              nodes[node.rightChild].aabbMax, tRight);

                if (hitLeft && hitRight) {
                    // Push farther child first so nearer is popped next
                    if (tLeft < tRight) {
                        stack[top++] = node.rightChild;
                        stack[top++] = node.leftChild;
                    } else {
                        stack[top++] = node.leftChild;
                        stack[top++] = node.rightChild;
                    }
                } else if (hitLeft)  { stack[top++] = node.leftChild;  }
                  else if (hitRight) { stack[top++] = node.rightChild; }
                // Both miss: already culled by parent AABB test, push nothing
            }
        }
    }
    return rec;
}

// ── Shadow ray (visibility only — early-exit, minimal stack) ─────────────────
//
// Returns true if the segment [ro, ro + rd * maxDist] is unoccluded.
// Uses a reduced stack (32 entries) since most shadow ray BVH depths are
// shallow, saving register pressure vs. the full 64-entry traversal stack.

bool shadowRay(vec3 ro, vec3 rd, float maxDist) {
    vec3 invRd = 1.0 / rd;

    int stack[32];
    int top = 0;
    stack[top++] = 0;

    while (top > 0) {
        int     idx  = stack[--top];
        BVHNode node = nodes[idx];

        float aabbT;
        if (!intersectAABB(ro, invRd, node.aabbMin, node.aabbMax, aabbT))
            continue;
        if (aabbT > maxDist) continue;

        if (node.primCount > 0) {
            for (int i = node.primStart; i < node.primStart + node.primCount; i++) {
                float t; vec2 bary;
                // Any hit closer than maxDist means the path is blocked
                if (intersectTriangle(ro, rd, i, t, bary) && t < maxDist)
                    return false;
            }
        } else {
            if (top < 30) {
                stack[top++] = node.rightChild;
                stack[top++] = node.leftChild;
            }
        }
    }
    return true; // unoccluded
}

// ── Sampling helpers ──────────────────────────────────────────────────────────

vec3 sampleCosineHemisphere(vec2 u, vec3 n) {
    float r   = sqrt(u.x);
    float phi = 6.28318530718 * u.y;
    vec3 local = vec3(r * cos(phi), r * sin(phi), sqrt(max(0.0, 1.0 - u.x)));

    vec3 up = abs(n.y) < 0.9999 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);
    vec3 t  = normalize(cross(up, n));
    vec3 b  = cross(n, t);

    return normalize(mat3(t, b, n) * local);
}

// Sample a point uniformly on a regular N-gon using triangle fan decomposition.
// This produces N-bladed bokeh exactly matching physical aperture polygons.
vec2 sampleNGon(inout uint seed, float radius, int N) {
    float r1 = rand(seed), r2 = rand(seed);
    if (r1 + r2 > 1.0) { r1 = 1.0 - r1; r2 = 1.0 - r2; }

    int   sector = int(rand(seed) * float(N));
    float a0 = 6.28318530718 * float(sector)     / float(N);
    float a1 = 6.28318530718 * float(sector + 1) / float(N);

    vec2 v0 = vec2(cos(a0), sin(a0));
    vec2 v1 = vec2(cos(a1), sin(a1));
    return (r1 * v0 + r2 * v1) * radius;
}

// ── NEE: Direct light sampling ────────────────────────────────────────────────
//
// Selects one emissive triangle from LightBuffer using the pre-built CDF,
// samples a uniform point on it, tests visibility via a shadow ray, and
// returns the direct Lambertian contribution for that sample.
//
// PDF derivation:
//   P(pick light i)   = light.power / u_totalLightPower          [CDF selection]
//   P(point on tri)   = 1 / light.area                           [uniform area]
//   Convert area → solid-angle:  pdf_sa = (1/area) * dist² / cosLight
//   Total PDF         = pickPdf * pdf_sa
//
//   Lo = (albedo/PI) * Le * cosHit / totalPdf
//
// cosLight uses abs() to handle both-face normals from the triangle buffer —
// the emitter geometry in a Cornell box is always enclosed so back-facing
// samples are blocked by the geometry in the shadow test anyway.

vec3 sampleDirectLight(vec3 hitPos, vec3 n, vec3 albedo, inout uint seed) {
    if (u_lightCount <= 0 || u_totalLightPower <= 0.0) return vec3(0.0);

    // ── 1. Select a light by CDF ──────────────────────────────────────────────
    float uSelect = rand(seed);
    int selected = u_lightCount - 1;
    for (int i = 0; i < u_lightCount; i++) {
        if (uSelect < lights[i].cdfWeight) { selected = i; break; }
    }
    Light light = lights[selected];
    float pickPdf = light.power / u_totalLightPower;
    if (pickPdf <= 0.0) return vec3(0.0);

    // ── 2. Sample uniform point on the selected triangle ─────────────────────
    float r1 = rand(seed), r2 = rand(seed);
    if (r1 + r2 > 1.0) { r1 = 1.0 - r1; r2 = 1.0 - r2; }
    vec3 lightPos = light.v0 + r1 * (light.v1 - light.v0) + r2 * (light.v2 - light.v0);

    // ── 3. Geometry terms ─────────────────────────────────────────────────────
    vec3  toLight   = lightPos - hitPos;
    float dist2     = dot(toLight, toLight);
    float dist      = sqrt(dist2);
    vec3  shadowDir = toLight / dist;

    float cosHit = dot(n, shadowDir);
    if (cosHit <= 0.0) return vec3(0.0);

    float cosLight = abs(dot(light.normal, shadowDir));
    if (cosLight <= 0.0) return vec3(0.0);

    // Clamp dist² from below to prevent the area→solid-angle PDF singularity.
    // When dist < sqrt(light.area) we are geometrically "inside" the light's
    // subtended region and the 1/dist² estimator breaks down. By flooring dist²
    // at light.area we keep the PDF well-conditioned without biasing samples at
    // normal distances (where dist >> sqrt(area) always holds).
    float dist2Safe = max(dist2, light.area);

    // ── 4. Visibility test ────────────────────────────────────────────────────
    // Offset origin along surface normal to avoid self-intersection.
    // Shrink maxDist by a small epsilon to avoid hitting the light surface itself.
    vec3 shadowOrigin = hitPos + n * 2e-3;
    if (!shadowRay(shadowOrigin, shadowDir, dist - 4e-3)) return vec3(0.0);

    // ── 5. Evaluate estimator ─────────────────────────────────────────────────
    float pdfSolidAngle = dist2Safe / (light.area * cosLight);  // uses clamped dist²
    float totalPdf      = pickPdf * pdfSolidAngle;
    if (totalPdf <= 0.0) return vec3(0.0);

    vec3 contrib = (albedo / 3.14159265359) * light.emission * cosHit / totalPdf;

    // Secondary safety clamp — now only fires in genuinely degenerate geometry,
    // not as a routine suppression mechanism.
    float emissionLum = dot(light.emission, vec3(0.299, 0.587, 0.114));
    return min(contrib, vec3(emissionLum * u_neeFireflyClamp));
    }

// ── Thin-lens ray generation with SA + LCA support ───────────────────────────

struct Ray { vec3 origin; vec3 dir; };

Ray generateRay(ivec2 pixel, inout uint seed, float focalDistOffset) {
    float aspect = float(u_resolution.x) / float(u_resolution.y);

    // Jittered sub-pixel for anti-aliasing
    vec2 jitter  = rand2(seed) - 0.5;
    vec2 ndcUV   = (vec2(pixel) + vec2(0.5) + jitter) / vec2(u_resolution);
    vec2 screen  = ndcUV * 2.0 - 1.0;

    // Pinhole (paraxial) ray direction
    vec3 pinholeDir = normalize(
        u_camForward
        + u_camRight * (screen.x * aspect * u_fovTanHalf)
        + u_camUp    * (screen.y          * u_fovTanHalf)
    );

    // Lens sample — determines DoF and bokeh shape
    vec2 lensSample = (u_lensRadius > 0.0)
        ? sampleNGon(seed, u_lensRadius, u_apertureBlades)
        : vec2(0.0);

    // ── Spherical Aberration ──────────────────────────────────────────────────
    float normalizedR2 = (u_lensRadius > 1e-6)
        ? clamp(dot(lensSample, lensSample) / (u_lensRadius * u_lensRadius), 0.0, 1.0)
        : 0.0;
    float effectiveFocalDist = u_focalDist + focalDistOffset + u_saStrength * normalizedR2;
    effectiveFocalDist = max(effectiveFocalDist, 0.01);

    // Project pinhole ray to the focal plane
    float tFocal  = effectiveFocalDist / dot(pinholeDir, u_camForward);
    vec3  focalPt = u_camPos + pinholeDir * tFocal;

    // Final ray from lens sample point toward focal point
    vec3 rayOrigin = u_camPos
        + u_camRight * lensSample.x
        + u_camUp    * lensSample.y;
    vec3 rayDir    = normalize(focalPt - rayOrigin);

    return Ray(rayOrigin, rayDir);
}

// ── Path trace ────────────────────────────────────────────────────────────────
//
// NEE strategy:
//   At every Lambertian (diffuse) surface hit, we explicitly sample the light
//   sources via a shadow ray (sampleDirectLight). This directly estimates the
//   first-order lighting integral with low variance.
//
//   To avoid double-counting, we track lastBounceWasDiffuse. When a BSDF-sampled
//   path ray hits an emissive surface after a diffuse bounce, we suppress adding
//   that emitter's contribution (NEE already accounted for it). If the previous
//   bounce was specular (glass/metal) or this is the camera ray (bounce 0), we
//   DO add the emitter contribution because NEE cannot sample delta BSDFs.

vec3 traceRadiance(Ray ray, inout uint seed, out vec3 o_firstHitAlbedo) {
    o_firstHitAlbedo = vec3(1.0); // default: sky miss → no albedo modulation
    vec3 radiance   = vec3(0.0);
    vec3 throughput = vec3(1.0);
    vec3 ro = ray.origin;
    vec3 rd = ray.dir;

    // false = camera / specular bounce — emitter hits should be counted.
    // true  = previous bounce was diffuse — NEE already handled direct light.
    bool lastBounceWasDiffuse = false;

    const int MAX_BOUNCES = 6;

    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {
        HitRecord hit = traverseBVH(ro, rd);

        if (!hit.valid) {
            // Black sky for enclosed Cornell box
            break;
        }

        Material mat = materials[hit.matIndex];

        // Two-sided shading — flip normal to face incoming ray
        vec3 n = dot(rd, hit.normal) < 0.0 ? hit.normal : -hit.normal;
        // Capture first-hit albedo for SVGF-style irradiance demodulation.
        // Transmissive materials use vec3(1.0) to avoid demodulation on refracted paths.
        if (bounce == 0) {
            o_firstHitAlbedo = (mat.transmission > 0.5) ? vec3(1.0) : mat.albedo;
        }

        // ── Emission ──────────────────────────────────────────────────────────
        // Skip emitter contribution when the previous bounce was diffuse:
        // NEE's shadow ray already sampled this light source directly.
        // Always count emission on the camera ray (bounce 0) and after
        // specular bounces (glass, metal) because NEE cannot handle delta BSDFs.
        if (!lastBounceWasDiffuse) {
            radiance += throughput * mat.emission * mat.emissionStrength;
        }

        // Russian roulette termination after bounce 2
        if (bounce >= 2) {
            float survive = max(mat.albedo.r, max(mat.albedo.g, mat.albedo.b));
            if (mat.metallic > 0.5 || mat.transmission > 0.5) survive = 0.95;
            survive = clamp(survive, 0.01, 0.95);
            if (rand(seed) > survive) break;
            throughput /= survive;
        }

        // ── BSDF selection ────────────────────────────────────────────────────
        if (mat.transmission > 0.5) {
            // ── Glass: Fresnel-weighted reflection / refraction ───────────────
            // Specular BSDF — no NEE (delta distribution)
            bool entering = dot(rd, hit.normal) < 0.0;
            float eta     = entering ? (1.0 / mat.ior) : mat.ior;
            float cosI    = abs(dot(rd, n));
            float r0      = (1.0 - mat.ior) / (1.0 + mat.ior); r0 *= r0;
            float F       = r0 + (1.0 - r0) * pow(clamp(1.0 - cosI, 0.0, 1.0), 5.0);

            if (rand(seed) < F) {
                rd = reflect(rd, n);
                ro = hit.pos + rd * 2e-3;
            } else {
                vec3 refracted = refract(rd, n, eta);
                if (dot(refracted, refracted) < 0.001) refracted = reflect(rd, n); // TIR
                rd = normalize(refracted);
                ro = hit.pos + rd * 2e-3;
            }
            throughput *= mat.albedo;
            lastBounceWasDiffuse = false;

        } else if (mat.metallic > 0.5) {
            // ── Metal: glossy reflection with roughness perturbation ──────────
            // Specular BSDF — no NEE
            vec3 reflected = reflect(rd, n);
            if (mat.roughness > 0.001) {
                vec3 up2 = abs(reflected.y) < 0.9999 ? vec3(0,1,0) : vec3(1,0,0);
                vec3 t2  = normalize(cross(up2, reflected));
                vec3 b2  = cross(reflected, t2);
                vec2 rnd = rand2(seed);
                float r2  = mat.roughness * sqrt(rnd.x);
                float phi2 = 6.28318530718 * rnd.y;
                vec3 perturb = r2 * (cos(phi2)*t2 + sin(phi2)*b2);
                reflected = normalize(reflected + perturb);
                if (dot(reflected, n) < 0.0) reflected = reflect(rd, n);
            }
            rd = reflected;
            ro = hit.pos + n * 2e-3;
            throughput *= mat.albedo;
            lastBounceWasDiffuse = false;

        } else {
            // ── Lambertian diffuse ────────────────────────────────────────────
            // NEE: explicitly sample a light source and add direct contribution.
            // This is the core variance-reduction step — replaces the need for a
            // BSDF-sampled ray to accidentally find the light.
            if (u_neeEnabled != 0) {
                radiance += throughput * sampleDirectLight(hit.pos, n, mat.albedo, seed);
            }

            // Continue path with a cosine-weighted hemisphere sample (indirect).
            rd          = sampleCosineHemisphere(rand2(seed), n);
            throughput *= mat.albedo;
            ro = hit.pos + n * 1e-3;
            lastBounceWasDiffuse = true;
        }
    }

    return radiance;
}

// ── G-buffer helper ───────────────────────────────────────────────────────────
// Returns (shading_normal.xyz, hit_t) for the primary ray's first hit.
// Used to seed the spatial denoiser on frame 0.  Sky/miss returns t = 1e4.
vec4 sampleGBuffer(Ray ray) {
    HitRecord hit = traverseBVH(ray.origin, ray.dir);
    if (!hit.valid) return vec4(0.0, 1.0, 0.0, 1e4);
    vec3 n = dot(ray.dir, hit.normal) < 0.0 ? hit.normal : -hit.normal;
    return vec4(n, hit.t);
}

// ── Main ──────────────────────────────────────────────────────────────────────
//
// Longitudinal CA implementation: see original header comment — unchanged.

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(pixel, u_resolution))) return;

    vec3 radiance;
    vec3 firstHitAlbedo;

    bool lcaActive = (abs(u_lcaDelta.r) + abs(u_lcaDelta.b)) > 1e-4;

    if (lcaActive) {
        uint seedR = initSeed(pixel, u_frameIndex * 3 + 0);
        uint seedG = initSeed(pixel, u_frameIndex * 3 + 1);
        uint seedB = initSeed(pixel, u_frameIndex * 3 + 2);

        vec3 albedoR, albedoG, albedoB;
        Ray rayR = generateRay(pixel, seedR, u_lcaDelta.r);
        float radR = traceRadiance(rayR, seedR, albedoR).r;

        Ray rayG = generateRay(pixel, seedG, u_lcaDelta.g);
        float radG = traceRadiance(rayG, seedG, albedoG).g;

        Ray rayB = generateRay(pixel, seedB, u_lcaDelta.b);
        float radB = traceRadiance(rayB, seedB, albedoB).b;

        radiance       = vec3(radR, radG, radB);
        firstHitAlbedo = albedoG; // green channel dominates luminance
    } else {
        uint seed = initSeed(pixel, u_frameIndex);
        Ray ray = generateRay(pixel, seed, 0.0);
        radiance = traceRadiance(ray, seed, firstHitAlbedo);
    }

    if (any(isnan(radiance)) || any(isinf(radiance))) radiance = vec3(0.0);

    // Accumulate sum(luma²) for per-pixel variance estimation in the denoiser.
    float lumaVal = dot(radiance, vec3(0.2126, 0.7152, 0.0722));
    float lumaSq  = lumaVal * lumaVal;

    if (u_frameIndex == 0) {
        imageStore(u_accumBuffer,    pixel, vec4(radiance, 1.0));
        imageStore(u_varianceBuffer, pixel, vec4(lumaSq, 0.0, 0.0, 0.0));

        // G-buffers are static during accumulation — write on first frame only.
        uint gbufSeed = initSeed(pixel, 99991);
        Ray  gbufRay  = generateRay(pixel, gbufSeed, 0.0);
        imageStore(u_gBuffer, pixel, sampleGBuffer(gbufRay));
        imageStore(u_gAlbedo, pixel, vec4(firstHitAlbedo, 1.0));
    } else {
        vec4 prev = imageLoad(u_accumBuffer, pixel);
        imageStore(u_accumBuffer, pixel, prev + vec4(radiance, 1.0));

        float prevLumaSq = imageLoad(u_varianceBuffer, pixel).r;
        imageStore(u_varianceBuffer, pixel, vec4(prevLumaSq + lumaSq, 0.0, 0.0, 0.0));
    }
}
