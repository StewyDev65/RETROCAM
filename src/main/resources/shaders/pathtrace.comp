#version 430 core
layout(local_size_x = 16, local_size_y = 16) in;

// ── Accumulation buffer (read previous sum, write new sum) ────────────────────
layout(rgba32f, binding = 0) uniform image2D u_accumBuffer;
layout(rgba16f, binding = 1) writeonly uniform image2D u_gBuffer;
layout(rgba16f, binding = 2) writeonly uniform image2D u_gAlbedo;     // first-hit albedo for irradiance demodulation
layout(r32f,    binding = 3) uniform image2D u_varianceBuffer;         // accumulated sum(luma²) for per-pixel variance

// ── Camera uniforms ───────────────────────────────────────────────────────────
uniform vec3  u_camPos;
uniform vec3  u_camRight;
uniform vec3  u_camUp;
uniform vec3  u_camForward;
uniform float u_focalDist;       // IIR-filtered focal distance (from TemporalState)
uniform float u_lensRadius;
uniform float u_fovTanHalf;
uniform int   u_apertureBlades;
uniform ivec2 u_resolution;
uniform int   u_frameIndex;      // 0 = first sample, clears accumulation
uniform sampler2D u_blueNoise;  // 64×64 RGBA8 blue-noise, GL_NEAREST + GL_REPEAT

// ── Phase 4 optical uniforms ──────────────────────────────────────────────────
uniform float u_saStrength;      // Spherical aberration strength (default 0.04)
uniform vec3  u_lcaDelta;        // LCA focal offsets for R, G, B (e.g. -0.002, 0.0, +0.003)

// ── Temporal uniforms ─────────────────────────────────────────────────────────
uniform float u_agcGain;
uniform float u_time;
uniform float u_tapeAge;

// ── NEE uniforms ──────────────────────────────────────────────────────────────
uniform int   u_lightCount;         // number of emissive triangles in LightBuffer
uniform float u_totalLightPower;    // sum of (luminance * area * PI) over all lights
uniform int   u_neeEnabled;         // 1 = use Next Event Estimation, 0 = pure path trace
uniform float u_neeFireflyClamp;    // max NEE contribution multiplier (default 20.0)
uniform int   u_samplesPerDispatch;   // inner sample loop count (1–16)

// ── GPU Scene Data ────────────────────────────────────────────────────────────

struct Triangle {
    vec3 v0; float pad0;
    vec3 v1; float pad1;
    vec3 v2; float pad2;
    vec3 n0; float pad3;
    vec3 n1; float pad4;
    vec3 n2; float pad5;
    vec2 uv0; vec2 uv1;
    vec2 uv2; int matIndex; float pad6;
};

struct BVHNode {
    vec3 aabbMin; float pad0;
    vec3 aabbMax; float pad1;
    int leftChild; int rightChild; int primStart; int primCount;
};

struct Material {
    vec3  albedo;          float metallic;
    vec3  emission;        float emissionStrength;
    float roughness;       float ior; float transmission; int albedoTex;
    float p0; float p1; float p2; float p3;
};

// Light struct layout matches SceneUploader (std430, 20 floats = 80 bytes):
//   vec3 v0 + area | vec3 v1 + pad | vec3 v2 + pad | vec3 emission + power | vec3 normal + cdfWeight
struct Light {
    vec3 v0;       float area;
    vec3 v1;       float pad1;
    vec3 v2;       float pad2;
    vec3 emission; float power;
    vec3 normal;   float cdfWeight;
};

layout(std430, binding = 0) readonly buffer TriBuffer   { Triangle triangles[]; };
layout(std430, binding = 1) readonly buffer BVHBuffer   { BVHNode  nodes[];     };
layout(std430, binding = 2) readonly buffer MatBuffer   { Material materials[]; };
layout(std430, binding = 3) readonly buffer LightBuffer { Light    lights[];    };

// ── PCG hash RNG ──────────────────────────────────────────────────────────────

uint pcg(inout uint state) {
    state = state * 747796405u + 2891336453u;
    uint w = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (w >> 22u) ^ w;
}

float rand(inout uint state) {
    return float(pcg(state)) / 4294967296.0;
}

vec2 rand2(inout uint state) { return vec2(rand(state), rand(state)); }

// Each channel gets an independent seed to ensure uncorrelated Monte Carlo samples.
// Multiplying frameIndex by 3 ensures no seed aliasing between channels across frames.
uint initSeed(ivec2 pixel, int frame) {
    uint s = uint(pixel.x + pixel.y * 7919 + frame * 6271);
    pcg(s); pcg(s);
    return s;
}

// ── Geometry helpers ──────────────────────────────────────────────────────────

bool intersectAABB(vec3 ro, vec3 invRd, vec3 bmin, vec3 bmax, out float tmin) {
    vec3 t0 = (bmin - ro) * invRd;
    vec3 t1 = (bmax - ro) * invRd;
    vec3 lo = min(t0, t1);
    vec3 hi = max(t0, t1);
    tmin = max(max(lo.x, lo.y), lo.z);
    float tmax = min(min(hi.x, hi.y), hi.z);
    return tmax >= max(tmin, 0.0);
}

bool intersectTriangle(vec3 ro, vec3 rd, int idx, out float t, out vec2 bary) {
    Triangle tri = triangles[idx];
    vec3 e1 = tri.v1 - tri.v0;
    vec3 e2 = tri.v2 - tri.v0;
    vec3 h  = cross(rd, e2);
    float a = dot(e1, h);
    if (abs(a) < 1e-8) return false;
    float  f = 1.0 / a;
    vec3   s = ro - tri.v0;
    float  u = f * dot(s, h);
    if (u < 0.0 || u > 1.0) return false;
    vec3   q = cross(s, e1);
    float  v = f * dot(rd, q);
    if (v < 0.0 || u + v > 1.0) return false;
    t = f * dot(e2, q);
    if (t < 1e-4) return false;
    bary = vec2(u, v);
    return true;
}

// ── BVH traversal (full — returns closest hit) ────────────────────────────────

struct HitRecord {
    bool  valid;
    float t;
    vec3  pos;
    vec3  normal;
    int   matIndex;
};

HitRecord traverseBVH(vec3 ro, vec3 rd) {
    HitRecord rec;
    rec.valid = false;
    rec.t = 1e30;

    vec3 invRd = 1.0 / rd;

    int stack[64];
    int top = 0;
    stack[top++] = 0;

    while (top > 0) {
        int     idx  = stack[--top];
        BVHNode node = nodes[idx];

        float aabbT;
        if (!intersectAABB(ro, invRd, node.aabbMin, node.aabbMax, aabbT))
            continue;
        if (aabbT > rec.t) continue;

        if (node.primCount > 0) {
            for (int i = node.primStart; i < node.primStart + node.primCount; i++) {
                float t; vec2 bary;
                if (intersectTriangle(ro, rd, i, t, bary) && t < rec.t) {
                    rec.t    = t;
                    rec.pos  = ro + rd * t;
                    Triangle tri = triangles[i];
                    float w = 1.0 - bary.x - bary.y;
                    rec.normal   = normalize(tri.n0 * w + tri.n1 * bary.x + tri.n2 * bary.y);
                    rec.matIndex = tri.matIndex;
                    rec.valid    = true;
                }
            }
        } else {
            if (top < 62) {
                // Order children by AABB hit distance — nearer child lands on
                // top of the stack so it is processed first, allowing rec.t to
                // tighten sooner and the aabbT > rec.t check to cull the farther
                // subtree earlier.  (Aila & Laine 2009)
                float tLeft, tRight;
                bool hitLeft  = intersectAABB(ro, invRd, nodes[node.leftChild].aabbMin,
                                              nodes[node.leftChild].aabbMax, tLeft);
                bool hitRight = intersectAABB(ro, invRd, nodes[node.rightChild].aabbMin,
                                              nodes[node.rightChild].aabbMax, tRight);

                if (hitLeft && hitRight) {
                    // Push farther child first so nearer is popped next
                    if (tLeft < tRight) {
                        stack[top++] = node.rightChild;
                        stack[top++] = node.leftChild;
                    } else {
                        stack[top++] = node.leftChild;
                        stack[top++] = node.rightChild;
                    }
                } else if (hitLeft)  { stack[top++] = node.leftChild;  }
                  else if (hitRight) { stack[top++] = node.rightChild; }
                // Both miss: already culled by parent AABB test, push nothing
            }
        }
    }
    return rec;
}

// ── Shadow ray (visibility only — early-exit, minimal stack) ─────────────────
//
// Returns true if the segment [ro, ro + rd * maxDist] is unoccluded.
// Uses a reduced stack (32 entries) since most shadow ray BVH depths are
// shallow, saving register pressure vs. the full 64-entry traversal stack.

bool shadowRay(vec3 ro, vec3 rd, float maxDist) {
    vec3 invRd = 1.0 / rd;

    int stack[32];
    int top = 0;
    stack[top++] = 0;

    while (top > 0) {
        int     idx  = stack[--top];
        BVHNode node = nodes[idx];

        float aabbT;
        if (!intersectAABB(ro, invRd, node.aabbMin, node.aabbMax, aabbT))
            continue;
        if (aabbT > maxDist) continue;

        if (node.primCount > 0) {
            for (int i = node.primStart; i < node.primStart + node.primCount; i++) {
                float t; vec2 bary;
                // Any hit closer than maxDist means the path is blocked
                if (intersectTriangle(ro, rd, i, t, bary) && t < maxDist)
                    return false;
            }
        } else {
            if (top < 30) {
                stack[top++] = node.rightChild;
                stack[top++] = node.leftChild;
            }
        }
    }
    return true; // unoccluded
}

// ── GGX Visible Normal Distribution Function (VNDF) sampling ─────────────────

// Samples only microsurface normals visible from the view direction wo,
// eliminating fireflies caused by near-zero pdf denominators in plain NDF
// sampling.  Weight simplifies to F*(G2/G1) which is always in [0,1].
// (Heitz 2017, "A Simpler and Exact Sampling Routine for the GGX
//  Distribution of Visible Normals")

vec3 sampleGGXVNDF(vec3 wo, float alpha, vec2 u) {
    // Stretch wo so we sample as though alpha == 1 (isotropic unit hemisphere)
    vec3 v = normalize(vec3(wo.x * alpha, wo.y, wo.z * alpha));

    // Orthonormal basis around v
    vec3 t1 = (v.y < 0.9999) ? normalize(cross(v, vec3(0.0, 1.0, 0.0)))
                              : vec3(1.0, 0.0, 0.0);
    vec3 t2 = cross(t1, v);

    // Sample a point on a disk, weighting each half proportionally to its
    // projected area onto v so that dot(h, wo) > 0 always holds.
    float a   = 1.0 / (1.0 + v.y);
    float r   = sqrt(u.x);
    float phi = (u.y < a) ? (u.y / a) * 3.14159265359
                          : 3.14159265359 + (u.y - a) / (1.0 - a) * 3.14159265359;
    float p1  = r * cos(phi);
    float p2  = r * sin(phi) * ((u.y < a) ? 1.0 : v.y);

    // Normal in stretched tangent space
    vec3 n = p1 * t1 + p2 * t2
           + sqrt(max(0.0, 1.0 - p1*p1 - p2*p2)) * v;

    // Unstretch and normalize — clamp n.y to avoid below-horizon normals
    return normalize(vec3(alpha * n.x, max(0.0, n.y), alpha * n.z));
}

// Smith G1 masking — fraction of microfacets visible along direction v
float smithG1GGX(float NdotV, float alpha) {
    float a2 = alpha * alpha;
    float denom = NdotV + sqrt(a2 + (1.0 - a2) * NdotV * NdotV);
    return 2.0 * NdotV / max(denom, 1e-7);
}

// Smith G2 height-correlated masking-shadowing (Heitz 2014)
// G2 <= G1 always, so F*(G2/G1) is bounded in [0,1] — no fireflies possible.
float smithG2GGX(float NdotL, float NdotV, float alpha) {
    float a2    = alpha * alpha;
    float denomA = NdotV * sqrt(a2 + (1.0 - a2) * NdotL * NdotL);
    float denomB = NdotL * sqrt(a2 + (1.0 - a2) * NdotV * NdotV);
    return 2.0 * NdotL * NdotV / max(denomA + denomB, 1e-7);
}

// ── Blue-noise sub-pixel sampler ──────────────────────────────────────────────
//
// Returns a blue-noise-distributed vec2 in [0,1)² for the given pixel and
// sample index.  A Cranley-Patterson toroidal shift (XOR of pixel coordinates
// with a hash of sampleIdx) decorrelates noise across frames while preserving
// the blue-noise spectral distribution within each frame.
//
// Using blue noise here instead of PCG white noise structures the per-pixel
// error as fine-grain spatial frequencies rather than low-frequency blobs,
// which the à-trous and OIDN denoisers handle significantly better at low SPP.

vec2 blueNoise2(ivec2 pixel, int sampleIdx) {
    // Hash sample index into a 12-bit offset for each axis
    uint h = uint(sampleIdx) * 2749558u + 1u;
    h ^= h >> 16u;
    h *= 0x45d9f3bu;
    h ^= h >> 16u;
    ivec2 coord = ivec2(
        (pixel.x ^ int(h        & 63u)),
        (pixel.y ^ int((h >> 6u) & 63u))
    ) & 63;
    return texelFetch(u_blueNoise, coord, 0).rg;
}

// ── Sampling helpers ──────────────────────────────────────────────────────────

vec3 sampleCosineHemisphere(vec2 u, vec3 n) {
    float r   = sqrt(u.x);
    float phi = 6.28318530718 * u.y;
    vec3 local = vec3(r * cos(phi), r * sin(phi), sqrt(max(0.0, 1.0 - u.x)));

    vec3 up = abs(n.y) < 0.9999 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);
    vec3 t  = normalize(cross(up, n));
    vec3 b  = cross(n, t);

    return normalize(mat3(t, b, n) * local);
}

// Sample a point uniformly on a regular N-gon using triangle fan decomposition.
// This produces N-bladed bokeh exactly matching physical aperture polygons.
vec2 sampleNGon(inout uint seed, float radius, int N) {
    float r1 = rand(seed), r2 = rand(seed);
    if (r1 + r2 > 1.0) { r1 = 1.0 - r1; r2 = 1.0 - r2; }

    int   sector = int(rand(seed) * float(N));
    float a0 = 6.28318530718 * float(sector)     / float(N);
    float a1 = 6.28318530718 * float(sector + 1) / float(N);

    vec2 v0 = vec2(cos(a0), sin(a0));
    vec2 v1 = vec2(cos(a1), sin(a1));
    return (r1 * v0 + r2 * v1) * radius;
}

// ── NEE: Direct light sampling ────────────────────────────────────────────────
//
// Selects one emissive triangle from LightBuffer using the pre-built CDF,
// samples a uniform point on it, tests visibility via a shadow ray, and
// returns the direct Lambertian contribution for that sample.
//
// PDF derivation:
//   P(pick light i)   = light.power / u_totalLightPower          [CDF selection]
//   P(point on tri)   = 1 / light.area                           [uniform area]
//   Convert area → solid-angle:  pdf_sa = (1/area) * dist² / cosLight
//   Total PDF         = pickPdf * pdf_sa
//
//   Lo = (albedo/PI) * Le * cosHit / totalPdf
//
// cosLight uses abs() to handle both-face normals from the triangle buffer —
// the emitter geometry in a Cornell box is always enclosed so back-facing
// samples are blocked by the geometry in the shadow test anyway.

vec3 sampleDirectLight(vec3 hitPos, vec3 n, vec3 albedo, inout uint seed) {
    if (u_lightCount <= 0 || u_totalLightPower <= 0.0) return vec3(0.0);

    // ── 1. Select a light by CDF ──────────────────────────────────────────────
    float uSelect = rand(seed);
    int selected = u_lightCount - 1;
    for (int i = 0; i < u_lightCount; i++) {
        if (uSelect < lights[i].cdfWeight) { selected = i; break; }
    }
    Light light = lights[selected];
    float pickPdf = light.power / u_totalLightPower;
    if (pickPdf <= 0.0) return vec3(0.0);

    // ── 2. Sample uniform point on the selected triangle ─────────────────────
    float r1 = rand(seed), r2 = rand(seed);
    if (r1 + r2 > 1.0) { r1 = 1.0 - r1; r2 = 1.0 - r2; }
    vec3 lightPos = light.v0 + r1 * (light.v1 - light.v0) + r2 * (light.v2 - light.v0);

    // ── 3. Geometry terms ─────────────────────────────────────────────────────
    vec3  toLight   = lightPos - hitPos;
    float dist2     = dot(toLight, toLight);
    float dist      = sqrt(dist2);
    vec3  shadowDir = toLight / dist;

    float cosHit = dot(n, shadowDir);
    if (cosHit <= 0.0) return vec3(0.0);

    float cosLight = abs(dot(light.normal, shadowDir));
    if (cosLight <= 0.0) return vec3(0.0);

    // Clamp dist² from below to prevent the area→solid-angle PDF singularity.
    // When dist < sqrt(light.area) we are geometrically "inside" the light's
    // subtended region and the 1/dist² estimator breaks down. By flooring dist²
    // at light.area we keep the PDF well-conditioned without biasing samples at
    // normal distances (where dist >> sqrt(area) always holds).
    float dist2Safe = max(dist2, light.area);

    // ── 4. Visibility test ────────────────────────────────────────────────────
    // Offset origin along surface normal to avoid self-intersection.
    // Shrink maxDist by a small epsilon to avoid hitting the light surface itself.
    vec3 shadowOrigin = hitPos + n * 2e-3;
    if (!shadowRay(shadowOrigin, shadowDir, dist - 4e-3)) return vec3(0.0);

    // ── 5. Evaluate estimator ─────────────────────────────────────────────────
    float pdfSolidAngle = dist2Safe / (light.area * cosLight);  // uses clamped dist²
    float totalPdf      = pickPdf * pdfSolidAngle;
    if (totalPdf <= 0.0) return vec3(0.0);

    vec3 contrib = (albedo / 3.14159265359) * light.emission * cosHit / totalPdf;

    // Secondary safety clamp — now only fires in genuinely degenerate geometry,
    // not as a routine suppression mechanism.
    float emissionLum = dot(light.emission, vec3(0.299, 0.587, 0.114));
    return min(contrib, vec3(emissionLum * u_neeFireflyClamp));
    }

// ── Thin-lens ray generation with SA + LCA support ───────────────────────────

struct Ray { vec3 origin; vec3 dir; };

Ray generateRay(ivec2 pixel, inout uint seed, float focalDistOffset, vec2 bnJitter) {
    float aspect = float(u_resolution.x) / float(u_resolution.y);

    // Blue-noise sub-pixel jitter — spatially structured error converges faster
    // and produces cleaner output for the denoiser than PCG white noise.
    vec2 jitter  = bnJitter - 0.5;
    vec2 ndcUV   = (vec2(pixel) + vec2(0.5) + jitter) / vec2(u_resolution);
    vec2 screen  = ndcUV * 2.0 - 1.0;

    // Pinhole (paraxial) ray direction
    vec3 pinholeDir = normalize(
        u_camForward
        + u_camRight * (screen.x * aspect * u_fovTanHalf)
        + u_camUp    * (screen.y          * u_fovTanHalf)
    );

    // Lens sample — determines DoF and bokeh shape
    vec2 lensSample = (u_lensRadius > 0.0)
        ? sampleNGon(seed, u_lensRadius, u_apertureBlades)
        : vec2(0.0);

    // ── Spherical Aberration ──────────────────────────────────────────────────
    float normalizedR2 = (u_lensRadius > 1e-6)
        ? clamp(dot(lensSample, lensSample) / (u_lensRadius * u_lensRadius), 0.0, 1.0)
        : 0.0;
    float effectiveFocalDist = u_focalDist + focalDistOffset + u_saStrength * normalizedR2;
    effectiveFocalDist = max(effectiveFocalDist, 0.01);

    // Project pinhole ray to the focal plane
    float tFocal  = effectiveFocalDist / dot(pinholeDir, u_camForward);
    vec3  focalPt = u_camPos + pinholeDir * tFocal;

    // Final ray from lens sample point toward focal point
    vec3 rayOrigin = u_camPos
        + u_camRight * lensSample.x
        + u_camUp    * lensSample.y;
    vec3 rayDir    = normalize(focalPt - rayOrigin);

    return Ray(rayOrigin, rayDir);
}

// ── Path trace ────────────────────────────────────────────────────────────────
//
// NEE strategy:
//   At every Lambertian (diffuse) surface hit, we explicitly sample the light
//   sources via a shadow ray (sampleDirectLight). This directly estimates the
//   first-order lighting integral with low variance.
//
//   To avoid double-counting, we track lastBounceWasDiffuse. When a BSDF-sampled
//   path ray hits an emissive surface after a diffuse bounce, we suppress adding
//   that emitter's contribution (NEE already accounted for it). If the previous
//   bounce was specular (glass/metal) or this is the camera ray (bounce 0), we
//   DO add the emitter contribution because NEE cannot sample delta BSDFs.

vec3 traceRadiance(Ray ray, inout uint seed, out vec3 o_firstHitAlbedo, out vec4 o_gBuffer) {
    o_firstHitAlbedo = vec3(1.0);
    o_gBuffer        = vec4(0.0, 1.0, 0.0, 1e4);
    vec3 radiance   = vec3(0.0);
    vec3 throughput = vec3(1.0);
    vec3 ro = ray.origin;
    vec3 rd = ray.dir;

    // false = camera / specular bounce — emitter hits should be counted.
    // true  = previous bounce was diffuse — NEE already handled direct light.
    bool lastBounceWasDiffuse = false;

    const int MAX_BOUNCES = 6;

    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {
        HitRecord hit = traverseBVH(ro, rd);

        if (!hit.valid) {
            // Black sky for enclosed Cornell box
            break;
        }

        Material mat = materials[hit.matIndex];

        // Two-sided shading — flip normal to face incoming ray
        vec3 n = dot(rd, hit.normal) < 0.0 ? hit.normal : -hit.normal;
        // Capture first-hit albedo for SVGF-style irradiance demodulation.
        // Transmissive materials use vec3(1.0) to avoid demodulation on refracted paths.
        if (bounce == 0) {
            o_firstHitAlbedo = (mat.transmission > 0.5) ? vec3(1.0) : mat.albedo;
            o_gBuffer        = vec4(n, hit.t);
        }

        // ── Emission ──────────────────────────────────────────────────────────
        // Skip emitter contribution when the previous bounce was diffuse:
        // NEE's shadow ray already sampled this light source directly.
        // Always count emission on the camera ray (bounce 0) and after
        // specular bounces (glass, metal) because NEE cannot handle delta BSDFs.
        if (!lastBounceWasDiffuse) {
            radiance += throughput * mat.emission * mat.emissionStrength;
        }

        // Russian roulette termination after bounce 2
        if (bounce >= 2) {
            float survive = max(mat.albedo.r, max(mat.albedo.g, mat.albedo.b));
            if (mat.metallic > 0.5 || mat.transmission > 0.5) survive = 0.95;
            survive = clamp(survive, 0.01, 0.95);
            if (rand(seed) > survive) break;
            throughput /= survive;
        }

        // ── BSDF selection ────────────────────────────────────────────────────
        if (mat.transmission > 0.5) {
            // ── Glass: Fresnel-weighted reflection / refraction ───────────────
            // Specular BSDF — no NEE (delta distribution)
            bool entering = dot(rd, hit.normal) < 0.0;
            float eta     = entering ? (1.0 / mat.ior) : mat.ior;
            float cosI    = abs(dot(rd, n));
            float r0      = (1.0 - mat.ior) / (1.0 + mat.ior); r0 *= r0;
            float F       = r0 + (1.0 - r0) * pow(clamp(1.0 - cosI, 0.0, 1.0), 5.0);

            if (rand(seed) < F) {
                rd = reflect(rd, n);
                ro = hit.pos + rd * 2e-3;
            } else {
                vec3 refracted = refract(rd, n, eta);
                if (dot(refracted, refracted) < 0.001) refracted = reflect(rd, n); // TIR
                rd = normalize(refracted);
                ro = hit.pos + rd * 2e-3;
            }
            throughput *= mat.albedo;
            lastBounceWasDiffuse = false;

        } else if (mat.metallic > 0.5) {
            // ── Metal: GGX VNDF microfacet specular ──────────────────────────
            // Samples the distribution of *visible* normals (Heitz 2017).
            // Weight = F * (G2/G1) which is always in [0,1] — no fireflies.

            vec3  wo    = -rd;                          // outgoing (view) direction
            float alpha = max(mat.roughness, 1e-3);

            // Tangent frame around shading normal
            vec3 up3 = abs(n.y) < 0.9999 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);
            vec3 T   = normalize(cross(up3, n));
            vec3 B   = cross(n, T);

            // Transform wo into local tangent space for VNDF sampling
            vec3 woLocal = vec3(dot(wo, T), dot(wo, n), dot(wo, B));

            // Sample visible half-vector in local space, rotate to world space
            vec3 hLocal = sampleGGXVNDF(woLocal, alpha, rand2(seed));
            vec3 h      = normalize(T * hLocal.x + n * hLocal.y + B * hLocal.z);

            // Reflect wo around h to get the incoming (scatter) direction
            rd = reflect(-wo, h);

            // Discard below-surface results — fall back to mirror
            if (dot(rd, n) <= 0.0) {
                rd = reflect(-wo, n);
            }

            float NdotL = max(dot(n, rd), 1e-4);
            float NdotV = max(dot(n, wo), 1e-4);
            float HdotV = max(dot(h,  wo), 1e-4);

            // Schlick Fresnel with metallic albedo as F0 (coloured specular)
            vec3  F  = mat.albedo + (1.0 - mat.albedo) * pow(1.0 - HdotV, 5.0);

            // VNDF weight: F * G2/G1 — always in [0,1], firefly-free
            float G1 = smithG1GGX(NdotV, alpha);
            float G2 = smithG2GGX(NdotL, NdotV, alpha);
            throughput *= F * (G2 / max(G1, 1e-7));

            ro = hit.pos + n * 2e-3;
            lastBounceWasDiffuse = false;
        } else {
            // ── Lambertian diffuse ────────────────────────────────────────────
            // NEE: explicitly sample a light source and add direct contribution.
            // This is the core variance-reduction step — replaces the need for a
            // BSDF-sampled ray to accidentally find the light.
            if (u_neeEnabled != 0) {
                radiance += throughput * sampleDirectLight(hit.pos, n, mat.albedo, seed);
            }

            // Continue path with a cosine-weighted hemisphere sample (indirect).
            rd          = sampleCosineHemisphere(rand2(seed), n);
            throughput *= mat.albedo;
            ro = hit.pos + n * 1e-3;
            lastBounceWasDiffuse = true;
        }
    }

    return radiance;
}

// ── Main ──────────────────────────────────────────────────────────────────────
//
// Longitudinal CA implementation: see original header comment — unchanged.

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(pixel, u_resolution))) return;

    bool lcaActive = (abs(u_lcaDelta.r) + abs(u_lcaDelta.b)) > 1e-4;

    vec2 bnJitter = blueNoise2(pixel, u_frameIndex);

    vec3 radiance;
    vec3 sAlbedo;
    vec4 sGBuffer;

    if (lcaActive) {
        uint seedR = initSeed(pixel, u_frameIndex * 3 + 0);
        uint seedG = initSeed(pixel, u_frameIndex * 3 + 1);
        uint seedB = initSeed(pixel, u_frameIndex * 3 + 2);

        vec4 gbR, gbG, gbB;
        vec3 albR, albG, albB;

        Ray rayR = generateRay(pixel, seedR, u_lcaDelta.r, bnJitter);
        float radR = traceRadiance(rayR, seedR, albR, gbR).r;

        Ray rayG = generateRay(pixel, seedG, u_lcaDelta.g, bnJitter);
        float radG = traceRadiance(rayG, seedG, albG, gbG).g;

        Ray rayB = generateRay(pixel, seedB, u_lcaDelta.b, bnJitter);
        float radB = traceRadiance(rayB, seedB, albB, gbB).b;

        radiance = vec3(radR, radG, radB);
        sAlbedo  = albG;
        sGBuffer = gbG;
    } else {
        uint seed = initSeed(pixel, u_frameIndex);
        Ray ray = generateRay(pixel, seed, 0.0, bnJitter);
        radiance = traceRadiance(ray, seed, sAlbedo, sGBuffer);
    }

    if (any(isnan(radiance)) || any(isinf(radiance))) radiance = vec3(0.0);

    float lumaVal = dot(radiance, vec3(0.2126, 0.7152, 0.0722));
    float lumaSq  = lumaVal * lumaVal;

    if (u_frameIndex == 0) {
        imageStore(u_accumBuffer,    pixel, vec4(radiance, 1.0));
        imageStore(u_varianceBuffer, pixel, vec4(lumaSq, 0.0, 0.0, 0.0));
        imageStore(u_gBuffer,        pixel, sGBuffer);
        imageStore(u_gAlbedo,        pixel, vec4(sAlbedo, 1.0));
    } else {
        vec4  prev       = imageLoad(u_accumBuffer,    pixel);
        float prevLumaSq = imageLoad(u_varianceBuffer, pixel).r;
        imageStore(u_accumBuffer,    pixel, prev + vec4(radiance, 1.0));
        imageStore(u_varianceBuffer, pixel, vec4(prevLumaSq + lumaSq, 0.0, 0.0, 0.0));
    }
}
